[[Home](./)]

## 그래프 모델

### 주제

  - [개요](#overview)
    - [3계층 lexical graph](#a-three-tiered-lexical-graph)
    - [컨텍스트 단위](#units-of-context)
  - [계보 계층](#lineage-tier)
  - [엔티티-관계 계층](#entity-relationship-tier)
  - [요약 계층](#summarisation-tier)
    - [사실](#facts)
    - [진술](#statements)
    - [토픽](#topics)

### 개요

lexical-graph는 비정형 소스에서 자동 생성된 계층적 [lexical graph](https://graphr.ag/reference/knowledge-graph/lexical-graph-hierarchical-structure/) 형태를 사용하며, 이 그래프의 역할은 질의응답 시스템이 *질문과 의미적으로 유사하지 않지만* 그럼에도 *답변에 관련된* 정보를 검색하는 것을 돕는 것입니다.

#### 3계층 lexical graph

lexical graph는 세 가지 계층으로 구성됩니다:

  - [**계보**](#lineage-tier) - 소스, chunk 및 그들 간의 관계.
  - [**요약**](#summarisation-tier) - 계층적 요약 및 다양한 세분화 수준의 어휘 단위.
  - [**엔티티-관계**](#entity-relationship-tier) - 기본 소스에서 추출된 개별 엔티티 및 관계.

![Lexical graph](../../images/lexical-graph.png)

#### 컨텍스트 단위

RAG 애플리케이션에서 lexical graph를 사용할 때, 어떤 크기의 어휘 단위가 컨텍스트의 기반이 되어야 하는지에 대한 질문이 제기됩니다.

많은 RAG 애플리케이션에서 컨텍스트의 기본 단위는 *chunk*입니다: 즉, 컨텍스트 창은 코퍼스에서 검색된 하나 이상의 chunk로 구성됩니다. 다양한 chunking 전략은 다양한 크기의 chunk를 생성합니다: chunk의 모든 경우에 적합한 정의는 없습니다. 그러나 이 문서의 목적상, chunk는 개별 문장보다 크지만 전체 문서보다는 작은 것으로 간주합니다.

graphrag-toolkit에서 컨텍스트의 기본 단위는 chunk가 아니라 독립적인 주장 또는 명제인 *진술*입니다. 소스 문서는 chunk로 나뉘고, 이 chunk에서 진술이 추출됩니다. 진술은 토픽별로 주제적으로 그룹화되며, 사실에 의해 뒷받침됩니다. 질의응답 시 lexical-graph는 진술 그룹(그리고 때로는 토픽 및/또는 사실)을 [검색](./querying.md)하여 LLM에 컨텍스트 창으로 제시합니다.

그래프는 질의응답 시스템이 질문과 의미적으로 유사하지 않지만 그럼에도 답변에 관련된 정보를 검색하는 것을 도울 수 있습니다. 의미적 유사성을 통한 검색은 여전히 중요한 전략이며, 질문과 의미적으로 유사한 컨텍스트는 종종 좋은 답변의 기초를 구성합니다. 그러나 유사성 기반 검색이 세밀한 응답을 생성하기에 항상 충분하지는 않으며, 많은 경우 vector 유사도 검색만으로는 찾을 수 없는 정보를 찾아 반환하여, LLM이 비교, 논증 및 요약을 개발하는 데 도움이 되는 더 차별화된 컨텍스트를 제시할 필요가 있습니다. 그래프의 관계는 검색 프로세스가 이러한 추가적인 관련 정보를 찾을 수 있는 수단을 제공합니다.

그래프 토폴로지와 그래프의 연결 정도는 관련 정보를 찾는 데 중요한 역할을 합니다. 모든 것이 다른 모든 것에 연결되어 있으면, 무관한 정보의 바다에서 특별히 관련된 컨텍스트 단위를 추출하기 어려워집니다. 반면, 그래프 요소 간의 연결이 낮으면, 관련되지만 의미적으로 유사하지 않은 정보의 금맥을 발견할 기회가 상대적으로 적습니다. graphrag-toolkit의 그래프 모델은 그래프의 여러 요소에 로컬 및 글로벌 연결 역할을 할당합니다: 토픽은 동일한 소스에서 파생된 진술 간의 주제적 연결을 제공하고, 사실은 서로 다른 소스에서 파생된 진술 간의 연결을 제공합니다.

### 계보 계층

이 계층은 `__Source__` 노드와 `__Chunk__` 노드로 구성됩니다. 소스 노드는 소스 문서를 설명하는 메타데이터(예: 작성자, URL, 게시 날짜)를 포함합니다. 정확한 메타데이터는 소스에 따라 다릅니다. chunk는 실제 chunk된 텍스트(및 그 embedding)를 포함합니다. chunk는 이전, 다음, 상위 및 하위 chunk에 연결됩니다.

### 엔티티-관계 계층

이 계층은 `__Entity__` 노드와 `__RELATION__` 관계로 구성됩니다. 엔티티는 값(예: 'Amazon')과 분류(예: 'Company')를 가집니다. 관계는 값(예: 'WORKS_FOR')을 가집니다.

엔티티-관계 계층의 엔티티는 상향식, 키워드 기반(정확 일치) 검색을 위한 그래프 진입점 역할을 합니다.

모든 엔티티는 `__SUBJECT__` 또는 `__OBJECT__`로서 최소 하나의 `__Fact__`와 연관됩니다. 엔티티는 여러 역할을 수행할 수 있습니다: 엔티티가 하나의 사실에서는 주어 역할을 하고 다른 사실에서는 목적어 역할을 할 수 있습니다.

추출은 추출 프로세스가 선호하는 엔티티 분류 목록으로 시드되는 가볍게 안내되는 전략을 사용합니다. LLM은 새로운 분류를 만들기 전에 목록에서 기존 분류를 사용하도록 지시받습니다. LLM이 도입한 새로운 분류는 후속 호출에 전달됩니다. 이 접근 방식은 엔티티 분류의 원치 않는 변형을 줄이지만 완전히 제거하지는 못합니다.

관계 값은 현재 안내되지 않습니다(상대적으로 간결하지만).

### 요약 계층

현재 이 계층은 `__Topic__`, `__Statement__` 및 `__Fact__` 노드로 구성됩니다. 아래에서 위로 진행하면:

#### 사실

사실은 단일 트리플릿 또는 트리플과 유사한 의미 단위를 요약합니다. 예:

```
Property Graph model ACCESSED WITH openCypher
```

사실에는 두 가지 유형이 있습니다: 주어-술어-목적어(SPO) 사실과 주어-술어-보어(SPC) 사실입니다. SPO 사실은 주어와 목적어 위치의 엔티티에 연결됩니다. SPC 사실은 주어 엔티티에만 연결됩니다. SPC 사실의 예:

```
Neptune Analytics PURPOSE analyze graph data
```

SPO 사실은 `__NEXT__` 관계를 통해 다른 사실에 연결되며, 첫 번째 사실의 목적어 엔티티가 후속 사실의 주어 엔티티 역할을 합니다.

사실은 *서로 다른 소스 간의 연결*을 제공합니다. 기본 코퍼스에서 개별 사실이 여러 번 언급되는 것은 드문 일이 아닙니다: 예를 들어, 뉴스 기사 데이터셋에서 특정 사실이 동일한 사건을 보도하는 다른 뉴스 기사에서 반복될 수 있습니다. 그래프에서는 이 특정 사실을 나타내는 단일 노드가 있습니다. 이 노드에서 진술, 토픽 및 chunk를 통해 해당 특정 사실이 언급된 모든 곳으로 탐색할 수 있습니다.

모든 사실은 최소 하나의 진술을 `__SUPPORTS__`합니다. 사실은 동일하거나 다른 토픽 및 소스에 속하는 여러 진술을 지원할 수 있습니다.

사실은 선택적으로 embedding될 수 있으며, 따라서 연결성을 향상시키는 것 외에도 그래프로의 저수준 vector 기반 진입점을 제공하는 데 사용할 수 있습니다.

#### 진술

기본 소스에서 추출된 진술 또는 주장입니다. 진술은 *컨텍스트 창에서 질의응답 LLM에 반환되는 기본 컨텍스트 단위*입니다 - 즉, 컨텍스트는 소스 및 토픽별로 그룹화된 진술 모음으로 구성됩니다.

진술은 일반적으로 하나 이상의 사실(SPO 및 SPC 사실 모두)과 연관됩니다. 예:

```
Statement
---------
Neptune supports open graph APIs for property graphs (Gremlin and openCypher) and RDF graphs (SPARQL)

Facts
-----
SPARQL FOR RDF graphs
SPARQL API FOR RDF graphs
openCypher API FOR property graphs
Gremlin FOR property graphs
Gremlin API FOR property graphs
openCypher FOR property graphs
```

경우에 따라 진술에는 관련 사실 외에 하나 이상의 상황적 *세부 사항*이 포함될 수 있습니다. 이러한 상황적 세부 사항은 사실과 동일한 트리플릿 형태를 취하지만, 엔티티(주어 또는 목적어) 관계가 없으므로 진술 노드에 속성으로 인라인됩니다.

진술은 토픽(아래 참조) 아래에 그룹화됩니다. 특정 토픽 내에서 진술은 `__PREVIOUS__` 관계를 통해 연결 목록으로도 연결되어 동일한 기본 소스에 속하는 이전(및 후속) 진술을 쉽게 검색할 수 있습니다.

진술은 질의응답을 위한 기본 컨텍스트 단위 역할을 합니다. 사실과 토픽을 통해 다른 진술과 전이적으로 연결됩니다.

진술은 선택적으로 embedding될 수 있으며, 따라서 vector 검색을 기반으로 그래프의 상위 수준 진입점 역할을 할 수 있습니다. 의미 기반 검색은 진술 embedding을 사용하여 검색 전략을 안내합니다. 진술 embedding은 또한 간단한 질문에 답하기 위해 상대적으로 작은 컨텍스트 조각을 검색하는 '기본 RAG' 방식으로 진술을 사용할 수 있게 합니다.

#### 토픽

토픽은 특정 소스 문서 내의 주제 또는 관심 영역입니다. 소스 문서에는 일반적으로 여러 토픽이 있습니다. 예를 들어, Neptune 문서 예제의 소스 문서 중 하나에는 다음과 같은 토픽이 있습니다:

```
Neptune Analytics
Loading Graph Data into Amazon Neptune Analytics
```

토픽은 단일 소스 내에서 chunk 간의 연결을 제공하기 위해 개별 소스 문서로 범위가 지정됩니다. 동일한 소스의 여러 chunk가 동일한 토픽에 연결되는 것이 일반적입니다.

토픽은 *단일 소스 내에서 관련 chunk 간의 연결*을 증가시키고, 간단한 문서 수준 요약 메커니즘을 제공합니다.

토픽은 선택적으로 embedding될 수 있으며, 따라서 vector 검색을 기반으로 그래프의 상위 수준 진입점 역할을 할 수 있습니다. 토픽 embedding은 토픽 이름과 해당 토픽에 속하는 모든 진술을 나타냅니다.

